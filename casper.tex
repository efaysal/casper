\documentclass[11pt,a4paper]{article}
\usepackage{amsmath,amsfonts,amssymb,amsthm,color,epsfig,epstopdf,titling,url,graphicx,array}

\marginparwidth = 10pt
\oddsidemargin = 10pt
\textwidth = 430pt


\title{Casper the Friendly Ghost: \\
		\vspace{2.5mm}
		\small A ``Proof-of-Stake'' Blockchain-based Consensus Protocol}
\date{April 24, 2015}
\author{Vlad Zamfir}


\begin{document}

\maketitle%Maybe put ccrg, ethereum logos on the title page?

\tableofcontents

\pagebreak

\section{Abstract}

This work is an adaptation of the Greedy Heaviest-Observed Sub-Tree\cite{GHOST} (GHOST) algorithm for security-deposit based consensus protocols. While the protocol described here is economic, it is almost trivial to turn Casper into a non-economic blockchain-based consensus protocol. 

This work contains three notable contributions to consensus research: It is a blockchain-based consensus protocol to quickly achieve finality of transaction confirmation when the network is synchronous and is simultanenously available in the event of asynchronocity and network partitions. Secondly, the protocol is able to quickly and continuously report to clients the status of the execution and finality of their transactions. Finally, it gives a strong economic assurance that validators will not suppress the blocks and validation signatures created by any subset of the validators.


\section{Introduction}

Blockchain-based consensus algorithms choose between forks of changes to the consensus state, rather than irreversibly commiting changes to the consensus, as traditional consensus algorithms aim to do. This is in order to be available, instead of consistent, in the event of network partitions; but to nonetheless come to consensus after the partitions end and the network reconnects \cite{ReformalizingConsensus}. We will specify an economic blockchain-based consensus protocol, which we see is also a non-economic consensus protocol. 

Casper the Friendly Ghost is a security-deposit based consensus protocol that incentivizes \emph{bonded validators} to coordinate the consensus. It is a generalization of GHOST, a protocol that chooses trees rather than chains of blocks. Therefore, we will introduce a partition of the consensus state into the consensus manager and the application state, so that we can fit tree-based algorithms as blockchain-based protocols.

\subsection{Security-deposit based consensus protocols}

Economic consensus protocols work by making byzantine faults expensive. The security-deposit approach to economic consensus uses security deposits (also known as ``surety-bonds'', or simply as ``bonds'') to make faults expensive. Nodes who wish to maintain the consensus by proposing and approving updates to the consensus must first place a security deposit under the protocol's control. When nodes are found to be byzantine, or even possibly when they are performing poorly according to metrics measured in the consensus, they will lose all or some of their security deposit. The surety-bond approach makes it easy for the protocol's engineer to specify when and how much nodes who maintain the consensus, (\emph{validator nodes}), should be punished.

Notable examples of surety-bond-based consensus protocols are Tendermint\cite{TM}, Pebble\cite{Pebble}, Slasher\cite{Slasher}, and Flying Fox\cite{FlyingFox}. Each of these protocols revoke a validator's security deposit if they sign or commit to two directly competing proposals to change the applcation state or if they propose or approve an invalid change. Additionally, Pebble and Flying Fox additionally charge validators for the privilege of proposing changes to the application state, insisting that they must make up these costs in transaction fees in order to be profitable. Casper also charges validators in order to participate - in particular we suggest that half of their security deposit are placed up-front in a pool, to be dispensed together with transaction fees. This pool can be wholly re-earned by the validators if they successfully play a cooperative coordination game.

\subsection{Ghost: Greedy heaviest-observed sub-tree}

The Ghost protocol for proof-of-work consensus\cite{GHOST} is an important innovation for blockchain-based consensus protocols even outside the scope of proof-of-work. It has the potential both to dramatically accelerate the rate of block creation, and makes the by-block state transition function aware of, and even participate in the consensus process. The ``heaviest-observed sub-tree'' rule is an instance of a generalized kind of fork-choice rule; one that allows the consensus to execute transactions from blocks that were created in parallel and hence are not chained together in sequence, but rather in a tree; this is done by allowing blocks to have multiple parents and for the state to be a function of a tree containing those blocks in different branches. It is possible to represent all sub-tree choice rules as a fork-choice rule. However, to do this we must make a subtle but important modification to our formalization of blockchain-based consensus protocols.

\subsection{Consensus manager}

The by-block state transition function $\Gamma$ is typically taken to directly upate the consensus state. We insist instead that the state has two parts: a \emph{consensus manager} and a \emph{consensus state}. The consensus manager is responsible for executing and possibly reverting transactions against the consensus state, which we will also refer to as the application state. This represents an important change to our definition of consensus protocols because it makes it possible for us to consider consensus to be only a function of the order of transactions executed (or reverted) against the application state, rather than to be solely determined by the fork-choice rule's choice. Even though a blockchain uniquely determines an application state, there may be many blockchains that give a particular application state. This additional ``wiggle room'' makes it possible for us to consider Ghost to be a blockchain-based consensus protocol which keeps track of a tree of blocks in its consensus manager - and it also lets us see that it is possible for clients who never choose the same fork to nonetheless have consensus on the same application state. The primary purpose of this definition, though, is to separate the application state from the part of the consensus state that deals with managing the consensus process.

\section{Specification}

Blockchain-based consensus is a process of trial-and-error, where commitments to blocks are not irreversible commitments to the execution of the transactions of that particular block, rather they are somewhat blind attempts to come to consensus on the application state. Before executing transactions, Casper will wait to see how the attempt to agree went, only then executing the transactions that it turned out were sufficiently agreed upon. Additionally, blockchains allow us to have a system that will be available to clients regardless of aynchronicity and network partitions. We can use this delayed-execution method to report to clients how much validation their transactions have while they are pending and at execution, so clients will understand that a partition may later mean a reordering. Ultimately, when a network partition ends the application states we will insist must come to a compromised consensus, in the worst case by the abandonment of forks with viewer validator signatures. 

In accordance with the definition of blockchain-based consensus protocols given in the reformalization document\cite{ReformalizingConsensus}, we will specify Casper as a triple: a by-block state transition function, a consensus strategy, and a fork-choice rule. 



%Here we need to change the fee distribution and ghost depth to be only until finality
\subsection{By-block state transition function}

The by-block state transition function $\Gamma$ governs how the blocks update the consensus state. In our current slightly modified formalization, $\Gamma$ consists of the consensus mechanism and the application state. We will treat only the consensus mechanism, so that anyone can imagine that Casper is serving the particular use case they are interested in. We will additionally insist that the consensus mechanism recieves and manages all transaction fees, manages the set of validators, and includes anything in the consensus that aims to secure or modify the application state independent of the application's specification. 

Casper's by-block state transition function has a number of responsibilities. It must manage validator security deposits, allowing them to place and withdraw deposits, and also revoke them on the event that it discovers that a validator produces two validation signatures on two different blocks at the same height. It must keep track of orphan and estranged blocks that are are ``included'' by blocks in the blockchain. It has to choose the order in which transactions that received sufficient validation at a given recent height will be executed against the application state. Finally, it has to distribute fees and part of the client's deposit called a \emph{cooperation bond} to validators as an increasing function of their ability to come to consensus, as measured after a delay. The first of these responsbilities is covered in the next paragraph, the next two in the second, and the last in the third.

The way Casper currently manages security deposits could be modified without sacrificing any of Casper's friendliness. In the current specification, there is a fixed-length period of time for a multiple of which you can remain bonded. To simplify the discussion, let's call this period six months. In the first week of every six months, bonders for the subsequent six months must submit a bonding request, as well as have a bond of a particular minmum bond size on deposit with Casper. By allowing bonding for the next period to occur in only one week, clients who come online at almost any time, every six months, will be able to learn 100\% of the set of validators who will be maintaining the consensus the next time, six months from now, when must come online again to learn the new set of validators. This requirement of coming online irregularly is fundamental to surety-bond based consensus protocols if the set of bonders rotates. Notably, Casper revokes validator's deposits if he learns that the validator produced validations on two blocks at the same height, and it takes half of the validator's bonds in order to redistribute those funds together with transaction fees at a later time.

Casper keeps track of all of the blocks and validation signatures on recent blocks that he has seen via ``ghost inclusion'' in something we refer to as a \emph{ghost table}. The ghost table is kept only for blocks that have a height not more than constant (or variable) GHOST\_DEPTH lower than Casper's current height. Casper's estimation is that in the vast majority of cases he will be able to find almost all of the validation signatures for that height that he will ever find, before the ghost depth. Blocks contain ghost inclusions, which are added to the ghost table, and block proposers are paid out of transaction for adding inclusions of blocks or transactions to their proposals. Very notably Casper executes the transactions of the blocks at the height $H$ - GHOST\_DEPTH, where $H$ is the current height, as long as the blocks each have more than 20\% of the validation signatures and, in descending order of the number of validations for that block in Casper's table. Additionally, if the transactions in blocks at the previous height in the table have been executed and more than 80\% of valications have occured on one block, Casper executes the transactions in that block agains the application state.

If the validators fail to produce only one block at every height, they must try again, including their failure. If again on this next attempt they produce two blocks in parallel, they should include evidence of this failure at the next height, and so on, ad infinitum. Casper could produce two blockchains in parallel, and by virtue of their blocks including each other it is possible for the application states of both of these blockchains to be precisely the same. 

By using the table, Casper is made aware of how well the validators are meeting the protocol's expectations. For example, Casper suggests a round-robin ordering to the validators, and the validators earn fewer fees if they do not chain blocks in this order. In particular, fees earned by validators who validate or sign a block that skips $N$ validators in the round-robin will have their earnings from that block multiplied by a factor of $(1 - N/NUM\_VALIDATOR)^2$. 

Finally, and very notably, fees from a transaction are only paid when the block arrives at $H - GHOST\_DEPTH$, even if the transactions were executed earlier, and they are paid to validators only in proportion to the square of the percentage of validators who have validations on that block in the ghost table. Fees that are earned by Casper but not by the validators, including security deposits which are forfeit due to double-signing, should be burned, distributed to the stake which isn't bonded, or sent to a trusted party who is believed to be building a public good.
 
\subsection{Consensus Strategy}

As already indicated, Casper's state transition function pays validators more fees when they chain blocks in an assigned round-robin order. The question is how validators decide when to publish proposals, given that there might be crash-faults that prevent them from proposing blocks in the round-robin order. Accordingly, Casper suggests using one of two consensus strategies: a faster, synchronous, timeout-based strategy and a safer strategy that involves getting permission from a large proportion $p$ of the validators in order to skip allegedly faulty proposers. We strongly recommend sticking to the first strategy. Choosing the second strategy favours the safety of the validators' revenues rather than the prompt availability of a proposal.

Every validation includes a timestamp of the time at which the validator claims to have seen the block being validated. There is no mechanism for punishing validators who lie about these timestamps, in Casper's state transition function. However, if validators want to process blocks quickly while minimizing revenue lost due to two proposers' proposing blocks at the same height at the same time, then they greatly benefit from synchronizing their clocks and setting the timeout as a function of honest timestamps - therefore the consensus strategy suggests that validators do exactly that. The consensus strategy is the following two rules, onr for proposing and one for validating: propose a block on top of a recent valid block by the validator preceding you in the round-robin if you have it, otherwise wait $2N - 1$ timeouts to propose a block on top of a valid block recently proposed by a validator $N$ places before you, in the round-robin. Similarly, validate a block if it is the first observed block at a height by the proposer next-up in the round-robin, or wait $2N - 1$ timeouts to publish a validation of a block proposed by the $N$'th-next up validator. We use $2N - 1$ timeouts because we strongly suggest that no one publishes validatons in alternating timeouts, so that a byzantine proposer cannot publish his block to split the network between validating their block and the next proposer's block.

Now, the safe version is appropriate for asynchronous networks and hence will make it theoretically possible for validators to collect all of their fees even if they are unable to coordinate their timeouts. In the safe version, a validator must get $p\%$ of the other validators to approve their proposal, if they do not have a valid block from the previous validator in the round-robin. To be safe against byzantine faults in an asynchronous network, it is recommended that $p$ be at least two thirds. Safe mode is not recommended because the eventual consistency-via-revision property of blockchains should be able to deal sufficiently well with asynchrony, while byzantine faults are expensive and therefore not forseen to be a major concern. However, in the event that faults occur too often, safe mode \emph{may} be appropriate even in synchronous networks - however, we cannot make protecting the revenues of validators be a motivating design decisions that hurt the consensus application's user experience - so we recommend once more than safe mode not be chosen by the practitioner.

%To what extent can we make the fork-choice rule more trivial?
\subsection{Fork-choice Rule}

Casper's fork-choice rule is simple, but first we must define the concept of a \emph{blockchain ping}. A blockchain ping is a message with a timestamp, a recent block hash and a small amount of proof-of-work or a signature from an account with a balance. Notw that proposers may or may not earn a small amount of fees or issuance for including pings in blocks. The purpose of this ping is so that a client can have an interaction with the blockchain in order to be convinced that blocks that appear to be new truly are new, and they are not being subjected to a replay attack.

Another important concept is that of \emph{ghost groups}. A ghost group is a set of forks that are being produced at the same height, which may have consensus mechanism at different states, but nonetheless agreee on the application state. The fork choice rule has two parts: ping every ghost group, and then pick the fork with the most validation signatures in its ghost table, from the ghost group which gave the ping more validations (after waiting for a fixed amount of time, or for the number of validations per ping to more-or-less stop changing). Additionally we have the restriction that the fork-choice rule will never pick a fork that didn't include a block that the client knows recieved more than a large proportion $r$ of signatures. We lean towards defining $r$ in-protocol as a high proportion because the danger for a user who chooses a small $r$ is to lose their ability to rejoin the consensus, while a user with a very large $r$ might end up carrying around more of the blockchain that they might prefer. 

\subsection{Further modifications}

There are three main improvements that should be made to Casper before it can be said to be a truly safe and practical consensus system, as far as we know. The first modification is critical: that bonders must not be allowed to unbond until they have signed a new set of validators with $r$ of the validation signatures, and hence the new set of validators is considered to be final. Otherwise, it could be possible for a client to have a fork change who they now falsely believe will be the validator set when they come online subsequently.

The second one is a nice-to-have: if there are two divergent ghost groups with substantial validation power, and there is no evidence that there \emph{wasn't} a network split, we would like the consensus mechanism to be able to somehow strategically reroll the transactions that occured on both forks against the application state, in order to come to a \emph{compromise application state} rather than abandoning one fork to have thevalidators attempt to replay transactions from the other chain in whichever order has fewer invalid transactions. In this event, we should consider allowing validators to have their fee payments revised by the consensus mechanism so that they are not extraordinarily unprofitable; the reason that fewer fees were distributed to them was the suspicion that they were either incompetent or maliciously excluding validators. 

The final nice-to-have is the following method for accelerating block production. Instead of having only one round-robin, have Casper insist that the validators form two round-robins, each producing a distinct blockchain, which take turns executing transactions against the same application state. A block proposed on one chain at height $H$ would have to include a block on its chain $H-1$ and of the other chain at $H-2$, ensuring that the chains stay in lock-step. Additionally, Casper would like a way to balance the online validators between the two blockchains. By following this protocol, perhaps even with more round-robins, Casper is able to produce blocks much faster than they propagate accross the network, while still maintaining consensus on the application state, as blocks in these chains include each other, and validators on these chains validate blocks at every height on every chain. 

\section{Analysis}

In the first analysis we treat Casper as a non-economic consensus algorithm and consider its byzantine fault tolerance in varying network conditions, later we will consider Casper's incentive mechanisms. 

\subsection{Traditional Consensus Analysis}

When the network is synchronous, the correct validators will be able to use timeouts to coordinate signing the same block at every height, as there is only one proposer who is able to propose at every ``validation period'', while the next proposer in the round-robin can immediately create and have his block validated. In this case, crash-faulty nodes cause timeouts and are skipped. Byzantine nodes can lie about timestamps, or fail to put ghost or validation includes in their blocks without being ejected by the protocol. If the ghost depth is long enough the ghost includes will end up being included in time for the transaction execution. As long as there are not too many byzantine nodes, the timestamps should still be reliable enough for the network to minimize the timeout length - when a large percentage of nodes are lying about timestamps, the correct validators can still coordinate on a reasonable timeout if they have collectively pre-agreed to minimum and maximum timeout. They might consider moving to safe mode or trying to find another way to target their timeouts to maximize performance. 

In a synchronous network without partitions a correct quorum of >50\% of the bonded stake can ensure that the consensus is available and the transactions executed against the consensus state are never reverted. Note that clients cannot necessarily verify that these nodes that are are maintaining the consensus fork are correct, and would require more than 50\% of validations before considering a block final due to the fear of double-signing - but indeed a byzantine quorum of 49\% cannot revert blocks created and validated by a correct quorum of 51\%. Indeed, if the correct validators can synchronize their timeouts, a quorum of 49\% wouldn't even be able to cause a block at a given height to be executed ahead of another.

In asynchronous networks, safe mode is required for validators to reliably coordinate on skipping potentially-faulty block proposers - something that might be necessary even though we can sometimes rely ghost to deal with failures to coordinate on signing exactly one block at every height, and even though we can almost-surely rely on the fork-choice rule to eventually reach consensus. Safe mode relies on a majority of vaidators agreeing the skipping of proposers. Through this protocol for skipping offline nodes in a round-robin, correct nodes can agree on the currently-eligible proposer without synchronizing timeouts. If there are no network partitions and the ghost depth is long enough, we also have 49\% byzantine fault tolerance in the asynchronous case.  Unforunately, it might take a long time to skip proposers if you are too ``safe'', in the event of long network delays or a network partition. Therefore we recommend keeping safe mode off, and relying on the eventual consistency properties of the fork-choice rule to come to consensus when the network is sufficiently synchronous, in order that we can provide \emph{something} to the user of the consensus application. In this case, the byzantine fault analysis is similar to that from network split: Byzantine nodes must have a quorum that is larger than the largest group of correct nodes who are able to coordinate effectively to force blocks of their choosing to be executed first in the event of a remerge, or to be consensus in the event that clients and validators are able to move to their fork with the fork-choice rule.

In a network partition, validators on either side of the partition will create blocks and, very importantly, clients will be able to see in the ghost table that the validators have not provided finality to their transactions or pings. With a smaller quorum than is normally required to choose which block gets executed at a given height, Byzantine nodes could choose which partition's chain will ``win'' when they come to consensus, in the event that they are able to access the partitions. After a remerge where enough validators are connected, however, byzantine nodes will once again be powerless to revert or changes to the application state unless they have a majority of the bonded stake. During a network partition, therefore, is the opportune time for attack. A byzantine quorum only needs to ensure that the fork they maintain or support has more validation signatures than the forks in the other partitions, and therefore the fault tolerance can go as low as the highest number of validators in a partition. Casper can mitigate these attacks only by having a good process for choosing a compromise consensus in remerge in the event of a partition, and by clearly notifying clients that their transactions haven't been finalized so that a minimum number of important transactions are made and/or fail to process, and clients are left relatively satisfied with the service.

We beilieve that Casper is byzantine fault tolerant when the network is connected, available in the event of network partitions - and, very notably, it is able to give clients a precise measurement of the assurance of execution and finality their transaction has received.


\subsection{Economic Analysis}

Although an attacker cannot cause clients to revert behind a block where they have already seen $r$ of the validators commit their deposits to (if we assume that all validators are rational), they can permanently halt the consensus by bribing all of the validators to double-sign. Alternatively, an attacker can bribe the validator nodes to selectively ignore transactions and to skip certain blocks. Both of these attacks, of course, can only occur at a considerable cost to the attacker.

The other economic analysis that is necessary is an analysis of Casper's method of distributing transaction fees \emph{and} bonds in proportion to a metric of the validator's ability to meet Casper's implicit, high expectation that 100\% of validators will sign every block and that no validator will produce blocks out of the round-robin order. Specifically, recall that if $N$ proposers were skipped and a proportion $p \in (0,1]$ of the validators were known to have validated a block before it got past the ghost depth, then of fees earned by Casper in this block, he will pay only $p^2 \cdot (1 - N/NUM\_VALIDATORS)^2$ of them to the validators. Remember also that, as currently specified, half of a bonder's deposit is dispensed back to them in this way.

This withholding of fees and bonds puts the validators in a cooperative game where they have a strong incentive not to collude against any subset of the validators. In particular, skipping a validator's block or ignoring their validations is directly costly. It strongly incentivizes the validators to synchronize their timeouts by giving honest timestamps on their validation, since anything which helps the validators coordinate on signing the same block at every height helps them stay profitable. The upside to this incentive mechanism is that it gives us an economic assurance that the validators are trying to cooperate and to successfully come to consensus - rather than engage in adversarial behaviour, even if the control of the bonded stake is centralized in the hands of a small number of bonders. 

A notable potential downside of this scheme is that it might cause rational validators to elect not to process blocks at all, rather than to attempt and fail to come to consensus at their direct expense. In any case, paying the validator less fees in the event of a partition makes it cheaper to bribe the validator to not process transactions during the partition. The main downside of this game is for the validators; that a byzantine quorum or partition likely will cost the validators dearly. This might reduce the number of validator nodes who can remain solvent, and thereby make the network less decentralized and less economically secure. As these seem like potentially serious problems, we will try find a way to ensure that network partitions and byzantine faults make the validators a lot less profitable that they would ordinarily be, but not as unprofitable as they might be in Casper's current specification. 

We are optimistic that Casper's cooperative economics can incentivize a large set of validators to ``play nice'', even when a small number of depositors have many deposits and the rest have only a few deposits. We are confident that there is no cheap attack that reverts finalized transactions, but are unsure if modifications need to be made to make it more expensive to prevent the network from being available, in particular in the event of a partition or a significant number of byzantine faults, given that all nodes are rational.

\section{Conclusion}

We have presented a new blockchain-based consensus protocol. It is an adaptation of the Ghost protocol for proof-of-work to security-deposit-based economic consensus. This consensus protocol also serves as an effective byzantine fault tolerant non-economic, blockchain-based consensus protocol. Additionally, the protocol quickly achieves transaction finality in synchronous networks without partitions, and can provide users services with a measure of the economic assurance they are getting, in the event of asynchronicity and network partitions. In economic-Casper, the validators participate in a cooperative game that gives the users a strong assurance that they see all of the validations that the validators to which they are connected know about and that blocks are not being skipped to censor transactions. In particular, if the modifications given at the end of the protocol specification are made, we are confident that Casper can be a practical economic blockchain-based consensus protocol.

\bibliographystyle{plain}
\bibliography{mybib}

\end{document}
