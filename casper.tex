\documentclass[11pt,a4paper]{article}
\usepackage{amsmath,amsfonts,amssymb,amsthm,color,epsfig,epstopdf,titling,url,graphicx,array}

\marginparwidth = 10pt
\oddsidemargin = 10pt
\textwidth = 430pt


\title{Casper the Friendly Ghost: \\
		\vspace{2.5mm}
		\small A ``Proof-of-Stake'' Blockchain-based Consensus Protocol}
\date{May 18, 2015}
\author{Vlad Zamfir}


\begin{document}

\maketitle%Maybe put ccrg, ethereum logos on the title page?

\tableofcontents

\pagebreak

\section{Abstract}

This work is an adaptation of the Greedy Heaviest-Observed Sub-Tree\cite{GHOST} (GHOST) algorithm for security-deposit based consensus protocols. While the protocol described here is economic, it is almost trivial to turn ``Casper the Friendly Ghost'' into a non-economic blockchain-based consensus protocol. 

Casper quickly achieves finality of transaction confirmation when the network is synchronous and is simultaneously available in the event of asynchronocity and network partitions. The protocol rapidly and continuously reports to clients the status of the execution and finality of their transactions. Finally, Casper gives us an economic assurance that validators will not suppress the blocks and validation signatures created by any subset of the validators.


\section{Introduction}

Blockchain-based consensus algorithms choose between forks of changes to the consensus state, rather than irreversibly committing changes to the consensus in the style of traditional consensus algorithms. This can be used to create distributed consensus protocols that make their applications available in the event of network partitions; but which nonetheless come to consensus after the network reconnects \cite{ReformalizingConsensus}. We will specify an economic blockchain-based consensus protocol, which we will see also serves as a non-economic consensus protocol.

Before giving the specification, we will do an overview of security-deposit based consensus protocols and of GHOST; a ``proof-of-work'' consensus protocol that has a subtree choice rule rather than a fork choice. Additionally, we will introduce a partition of the consensus state into the ``consensus manager'' and the ``application state''. This separation of responsibilities allow us to create a blockchain-based consensus protocol equivalent to any blocktree-based consensus protocol.

\subsection{Security-deposit based consensus protocols}

Economic consensus protocols use digital assets defined in the consensus state to make byzantine faults expensive. The security-deposit approach to economic consensus uses security deposits (also known as ``surety-bonds'', or simply as ``bonds'') to make faults expensive. Specifically, nodes who wish to maintain the consensus by proposing and voting for updates to the consensus state must first place a security deposit under the protocol's control. When nodes are found to be byzantine, or even possibly when they are performing poorly according to metrics measured in the consensus, they will lose all or some of their security deposit. The surety-bond approach makes it easy for the protocol's engineer to specify how much and when the nodes who maintain the consensus, (\emph{validator nodes}), should be punished.

Notable examples of surety-bond-based consensus protocols are Tendermint\cite{TM}, Pebble\cite{Pebble}, Slasher\cite{Slasher}, and Flying Fox\cite{FlyingFox}. Each of these protocols revoke a validator's security deposit if they sign or propose two directly competing proposals to change the application state, or if they propose or approve an invalid change. Additionally, Pebble and Flying Fox charge validators for the privilege of proposing changes to the application state, insisting that they must make up these costs in transaction fees in order to be profitable. Somewhat similarly, Casper insists that a portion of validator security deposit is placed into a pool, where it will be dispensed back to the validators together with transaction fees. This pool is re-earned by the validators only as a function of their ability to coordinate the consensus. 

\subsection{Ghost: Greedy heaviest-observed sub-tree}

The GHOST protocol for proof-of-work consensus\cite{GHOST} is an important innovation for blockchain-based consensus protocols, even outside the scope of proof-of-work. It dramatically increases the rate of block creation, allowing nodes to come to consensus on the order of the execution of transactions in blocks that were created in parallel. It additionally can make the by-block state transition function aware of, react to, and reactively participate in the consensus process. The ``heaviest-observed sub-tree'' rule is an instance of a generalized kind of fork-choice rule; one that allows the consensus to execute transactions from blocks that are not chained together in sequence. GHOST blocks may have multiple parents, and the consensus state is a function of the tree containing those block. To place this feature in our framework of blockchain-based consensus, we must make a subtle but important modification to our understanding of blockchain-based consensus.

\subsection{Consensus managers}

The by-block state transition function is typically taken to directly update the consensus state. We instead consider the state to have two parts: a \emph{consensus manager} and a \emph{application state}. The consensus manager is responsible for executing and reverting transactions against the application state. Alternatively, the consensus manager can be understood as a map from blockchains to orders of transactions. Traditional blockchain-based consensus protocols have a consensus manager that executes or orders transactions against the application state in precisely the order that they appear in the blockchain.

This represents an important but subtle conceptual change to our definition of blockchain-based consensus protocols, because it makes it possible for us to consider consensus to be only a function of the order of transactions executed (or reverted) against the application state, rather than the order in which transactions appeared in the blockchain. Even though a blockchain uniquely determines an application state, there may be many blockchains that give a particular application state. This additional ``wiggle room'' makes it possible for us to consider GHOST as a blockchain-based consensus protocol that keeps track of a tree of blocks with its consensus manager. It also lets us see that it is possible for clients who never choose the same fork to nonetheless have consensus on the same application state. The other purpose of this definition is to separate the application state from the part of the consensus state that deals with managing the consensus, itself, including the distribution of transaction fees, the managment of bonds, etc.


\section{Specification}

Blockchain-based consensus is a process of trial-and-error, where commitments to blocks are not irreversible commitments to the execution of the transactions of that particular block, but rather are somewhat blind attempts to come to consensus on the application state. Additionally, blockchains allow us to have a system that will be available to clients regardless of the state of network synchrony and partitions.

In accordance with the definition of blockchain-based consensus protocols given in ``Reformalizing Consensus''\cite{ReformalizingConsensus}, we will specify Casper as a triple: a by-block state transition function, a consensus strategy, and a fork-choice rule.


\subsection{By-block state transition function}

The by-block state transition function governs how the blocks update the consensus state. In our current slightly modified formalization, the transition function updates the consensus manager and the application state. Casper is agnostic of the application state, so we will restrict our attention to transitions of the consensus manager's state. 

Casper's by-block state transition function has a number of responsibilities. It must manage validator security deposits, allowing them to place and withdraw deposits, and also revoke them on the event that it discovers that a validator produces two validation signatures on two different blocks at the same height. It must keep track of orphan blocks, and validations on orphan blocks. It has to determine the order in which transactions will be executed against the application state. Finally, it distributes fees to validators as a function of its knowledge of their attempts to come to consensus, as measured after sufficient delay. The first of these responsibilities is covered in the next subsection, the next two in the second, and the last in the third.


\subsubsection{Security deposit management}

The way Casper manages security deposits could be modified without sacrificing any of Casper's friendliness. In the current specification validators must remain bonded for a multiple of a fixed-length period of time. To simplify the discussion, let's call this period six months. In the first week of every six months, bonders for the subsequent six months must submit a bonding request, as well as have a bond of a particular minimum bond size on deposit with Casper. By allowing bonding for the next period to occur in only one week, clients who come online at almost any time every six months will be able to authenticate the set of validators who will be maintaining the consensus six months from then. This requirement of coming online irregularly is fundamental to surety-bond based consensus protocols if the set of bonders rotates. Notably, Casper revokes a validator's deposit (and role maintaining the consensus) if he learns that the validator produced validation signatures on two blocks at the same height. Finally, if a validator does not have validation included in the ghost table, for the whole ghost depth, then they are automatically unbonded.


\subsubsection{The ghost table and transaction ordering}

Casper keeps track of blocks and validation signatures on recent blocks in a datastructure in the consensus manager that we will refer to as \emph{the ghost table}. The ghost table is kept only for blocks that have a height not more than a large constant \emph{ghost depth} lower than Casper's current height. Blocks contain \emph{ghost inclusions} (blocks, and validations on blocks that aren't already in the ghost table) that are appended to the ghost table of the block's parent, to give the current block's table. Block proposers are incentivized to place as many inclusions in their block, as possible. Casper keeps track of all of blocks and validations in this table so that he can order transactions in the following manner: transactions included in blocks at lower heights get executed before transactions at higher heights, and transactions included in blocks with more validations at a given height get executed before transactions with less validations at that height.

It is notably possible for Casper to change the order of the execution of transactions included in blocks produced at the same height, as his knowledge of which block received more validations changes over time. We add two requirements to reduce the possible severity of this re-ordering: A bonder's validation of a block must include validations of lower heights if the validated block's ghost table does not already include any validations for that validator, at these heights. This rule ensures that the number of validations in the ghost table at height $H$ is not less than the number of validations in the ghost table at height $H + 1$. Additionally, if a block achieves \emph{the finality threshold} (say, 85\%) number of validations, or that block reaches the ghost depth, then the order of transactions at all lower heights is finalized (i.e. will never change).


\subsubsection{Distribution of transaction fees}

Some proportion of the validators' bonds are redistributed together with transaction fees. The larger this proportion, the stronger Casper's guarantee of censorship resistance becomes, and the more vulnerable validator revenues become to increasingly expensive byzantine faults. Transaction fees earned at a particular height are distributed only after Casper achieves finality on the order of transactions at that height, or the ghost depth is reached. Additionally we will insist that Casper wait some time after finality is reached, before distributing transaction fees, to wait for more validations to be included in its table.

By referring to the ghost table, Casper can learn how well the validators are meeting the protocol's expectations: Casper suggests a round-robin ordering to the validators, and any deviation from this order will be observed in the ghost table. Casper withholds transaction fees from validators to punish them if they do not chain blocks in this order. This provides a guarantee against the censorship of blocks; this mechanism makes it expensive to skip a block. Additionally, Casper punishes validators by withholding fees when less than all of the validators have validations included at a height, or when not all validators sign the same block at that height.

Fees that are earned by Casper but not by the validators, including security deposits which are forfeit due to double-signing should be burned, distributed to the stake which isn't bonded, or sent to a trusted party (or DAO) who is believed to be building a public good (as withholding fees or taking deposits when appropriate is a public good).

%Thinking about removing the safer strategy
\subsection{Consensus Strategy}

As already indicated, Casper's state transition function pays validators more fees when they chain blocks in an assigned round-robin order. The question that remains, then, is how Casper suggests that validators decide when to publish and validate block proposals, given that there might be crash-faults that prevent them from proposing blocks in the prescribed order. Accordingly, Casper suggests using one of two consensus strategies: a faster, synchronous, timeout-based strategy or a safer strategy that involves getting permission from a large proportion $p$ of the validators in order to skip allegedly faulty proposers. We strongly recommend sticking to the first strategy. Choosing the second strategy favours the safety of the validators' revenues rather than the prompt availability of a proposal. The safe strategy might not be possible in the event of partitions, while the fast strategy will always produce blocks.

Every validation includes a timestamp of the time at which the validator claims to have seen the block being validated. There is no mechanism for punishing validators who lie about these timestamps, in Casper's state transition function. However, if validators want to process blocks quickly while minimizing revenue lost due to two proposers' proposing blocks at the same height at the same time, then they greatly benefit from synchronizing their clocks and setting the timeout as a function of honest timestamps - therefore the consensus strategy suggests that validators do exactly that. The consensus strategy is the following two rules, one for proposing and one for validating: propose a block on top of a recent valid block by the validator preceding you in the round-robin if you have it, otherwise wait $2N - 1$ timeouts to propose a block on top of a valid block recently proposed by a validator $N$ places before you, in the round-robin. Similarly, validate a block if it is the first observed block at a height by the proposer next-up in the round-robin, or wait $2N - 1$ timeouts to publish a validation of a block proposed by the $N$'th-next up validator. We use $2N - 1$ timeouts because we require a pause between proposal times so that a byzantine proposer cannot time their block to split the network between validating their block and the next proposer's block.

The safe version is appropriate for asynchronous networks and hence will make it theoretically possible for validators to collect all of their fees even if they are unable to coordinate their timeouts. If they are following the safe consensus strategy, a validator must get $p\%$ of the other validators to approve their proposal, if they do not have a valid block from the previous validator in the round-robin. To be safe against byzantine faults in an asynchronous network, it is recommended that $p$ be at least two thirds. Safe mode sacrifices availability of services during network partitions or a large number of byzantine faults in return for the saftey of validator revenues, and is only important when validators cannot coordinate timeouts. Therefore we strongly recommended against ever using safe mode.


%To what extent can we make the fork-choice rule more trivial?
\subsection{Fork-choice Rule}

Casper's fork-choice rule is relatively simple, but we must define a couple of terms to specify it. A \emph{blockchain ping} is a message with a timestamp, a recent block hash and a small amount of proof-of-work or a signature from an account with a balance. Note that proposers may or may not earn a small amount of fees or issuance for including pings in blocks. The purpose of this ping is so that a client can have an interaction with the blockchain in order to be convinced that blocks that appear to be new truly are new, and they are therefore not being subjected to a replay attack.

A \emph{ghost group} is a set of forks, which may have consensus mechanism at different states, but nonetheless agree on the most recent finalized application state. The fork choice rule is an interactive protocol: ping every ghost group, wait a short amount of time, and then pick the fork with the most validation signatures in its ghost table from the ghost group which gave the ping the most validations. Additionally, we have the restriction that the fork-choice rule will never pick a fork that didn't include a block that the client knows received more than the finality threshold number of signatures.


\subsection{Further modifications}

There are three main modifications that should be made to Casper before it can be said to be a truly safe and practical consensus system. The first is a critical security modification, and the next two represent signifcant improvements to user experience.

This was not mentioned in the bond management section because requires an introduction to finality (either by reaching the threshold number of validations, or by getting to ghost depth): bonders must not be allowed to unbond until a bonding period after they have signed in a new set of validators with finality. This requirement is critical because it guarantees that validators will ``pass the torch'' without being able to subsequently make changes to the next validator set.

Secondly, if there are two divergent forks with substantial validation power, and there is no evidence that there \emph{wasn't} a network split, we would like the consensus mechanism to be able to somehow strategically reroll the transactions that occured on both forks against the application state, in order to come to a \emph{compromise application state} rather than abandoning one fork to have the validators attempt to replay transactions from the other chain in whichever order the validators are able. 

The final very-nice-to-have is the following method for accelerating block production. Instead of having only one round-robin, have Casper insist that the validators form two round-robins, each producing a distinct blockchain, which take turns executing transactions against the same application state. A block proposed on one chain at height $H$ would have to include a block on its chain $H-1$ and of the other chain at $H-2$, ensuring that the chains stay in lock-step. Additionally, Casper would like a way to balance the online validators between the two blockchains. By following this protocol, which is easily adapted to more round-robins, Casper is able to produce blocks much faster than they propagate across the network, while still maintaining rapid eventual consensus on the application state, as blocks in these chains include each other, and validators on these chains validate blocks at every height on every chain, and Casper re-orders transactions as necessary, in the manner described in the state transition function. 


\section{Analysis}

In the first analysis we treat Casper as a non-economic consensus algorithm and consider its byzantine fault tolerance in varying network conditions, later we will consider Casper's incentive mechanisms. 

\subsection{Traditional Consensus Analysis}

When the network is synchronous, the correct validators will be able to use timeouts to coordinate signing the same block at every height, as there is only one proposer who is able to propose at every ``validation period'', while the next proposer in the round-robin can immediately create and have his block validated. In this case, crash-faulty nodes cause timeouts and are skipped. Byzantine nodes can lie about timestamps, or fail to put ghost or validation includes in their blocks without being ejected by the protocol. If the ghost depth is long enough the ghost includes will end up being included in time for the transaction execution. As long as there are not too many byzantine nodes, the timestamps should still be reliable enough for the network to minimize the timeout length - when a large percentage of nodes are lying about timestamps, the correct validators can still coordinate on a reasonable timeout if they have collectively pre-agreed to minimum and maximum timeout, but they may not be able to synchronize their timeouts. They might consider moving to safe mode or trying to find another way to synchronize their timeouts to maximize performance. 

In a synchronous network without partitions, a correct quorum of >50\% of the bonded stake can ensure that the consensus is available and the transactions executed against the consensus state are never reverted. Note that clients cannot necessarily verify that these nodes that are are maintaining the consensus fork are correct, and would require more than 50\% of validations before considering a block final due to the fear of double-signing - but indeed a byzantine quorum of 49\% cannot revert blocks created and validated by a correct quorum of 51\%. If the correct validators can synchronize their timeouts, a quorum of 49\% wouldn't even be able to cause a block at a given height to be executed ahead of another.

In asynchronous networks, safe mode is required for validators to reliably coordinate on skipping potentially-faulty block proposers - something that might be necessary even though we can sometimes rely ghost to deal with failures to coordinate on signing exactly one block at every height, and even though we can almost-surely rely on the fork-choice rule to eventually reach consensus. Safe mode relies on a majority of validators agreeing the skipping of proposers. Through this protocol for skipping offline nodes in a round-robin, correct nodes can agree on the currently-eligible proposer without synchronizing timeouts. If there are no network partitions and the ghost depth is long enough, we also have 49\% byzantine fault tolerance in the asynchronous case.  Unfortunately, it might take a long time to skip proposers if you are too ``safe'', in the event of long network delays or a network partition. Therefore we recommend keeping safe mode off, and relying on the eventual consistency properties of the fork-choice rule to come to consensus when the network is sufficiently synchronous, in order that we can provide \emph{something} to the user of the consensus application. In this case, the byzantine fault analysis is similar to that from network split: Byzantine nodes must have a quorum that is larger than the largest group of correct nodes who are able to coordinate effectively to force blocks of their choosing to be executed first in the event of a re-merge, or to be consensus in the event that clients and validators are able to move to their fork with the fork-choice rule.

In a network partition, validators on either side of the partition will create blocks and, very importantly, clients will be able to see in the ghost table that the validators have not provided finality to their transactions or pings. With a smaller quorum than is normally required to choose which block gets executed at a given height, Byzantine nodes could choose which partition's chain will ``win'' when they come to consensus, in the event that they are able to access the partitions. After a re-merge where enough validators are connected, however, byzantine nodes will once again be powerless to revert or changes to the application state unless they have a majority of the bonded stake. During a network partition, therefore, is the opportune time for attack. A byzantine quorum only needs to ensure that the fork they maintain or support has more validation signatures than the forks in the other partitions, and therefore the fault tolerance can go as low as the highest number of validators in a partition. Casper can mitigate these attacks only by having a good process for choosing a compromise consensus in re-merge in the event of a partition, and by clearly notifying clients that their transactions haven't been finalized so that a minimum number of important transactions are made and/or fail to process, and clients are left relatively satisfied with the service.

We believe that Casper is byzantine fault tolerant when the network is connected, available in the event of network partitions - and, very notably, is able to give clients a precise measurement of the assurance of execution and finality their transaction has received.


\subsection{Economic Analysis}

Although an attacker cannot cause clients to revert transactions from a block that has the finality threshold of validation signatures, they can permanently halt the consensus by bribing all of the validators to double-sign. Alternatively, an attacker can bribe the validator nodes to selectively ignore transactions and to skip certain blocks. Both of these attacks, of course, can only occur at a cost to the attacker.

The other economic analysis that is necessary is an analysis of Casper's method of distributing transaction fees \emph{and} bonds in proportion to a metric of the validators' ability to meet Casper's implicit, high expectation that 100\% of validators will sign every block and that no validator will produce blocks out of the round-robin order.

This withholding of fees and bonds puts the validators in a cooperative game where they have a strong incentive not to collude against any subset of the validators. In particular, skipping a validator's block or ignoring their validations is directly costly. It strongly incentivizes the validators to synchronize their timeouts by giving honest timestamps on their validation, since anything which helps the validators coordinate on signing the same block at every height helps them stay profitable. The upside to this incentive mechanism is that it gives us an economic assurance that the validators are trying to cooperate and to successfully come to consensus rather than engage in adversarial behaviour, even if the control of the bonded stake is centralized in the hands of a small number of bonders. 

A notable potential downside of this scheme is that it might cause rational validators to unbond, rather than to attempt and fail to come to consensus at their direct expense. Paying the validator less fees in the event of a partition makes it cheaper to bribe the validator to not process transactions at all, during the partition. The main downside of this game is for the validators; that a byzantine quorum or partition likely will cost the validators dearly. This might reduce the number of validator nodes who can remain solvent, and thereby make the network less decentralized and less economically secure. However, the fact that byzantine faults are very costly gives us some assurance that attackers will not be willing to damage validator revenues are their own expense for very long.

We are optimistic that Casper's cooperative economics can incentivize a large set of validators to ``play nice'', even when a small number of depositors have most of the stake and the rest have only a few deposits, and we are confident that there is no cheap attack that reverts finalized transactions.

\section{Conclusion}

We have presented a new blockchain-based consensus protocol. It is an adaptation of the Ghost protocol for proof-of-work to security-deposit-based economic consensus. This consensus protocol also serves as an effective byzantine fault tolerant non-economic, blockchain-based consensus protocol. Additionally, the protocol quickly achieves transaction finality in synchronous networks without partitions, and can provide users services with a measure of the economic assurance they are getting, and so is able to provide useful services in the event of asynchronicity and network partitions without putting its users at unknown risk of transaction reversion. 

The validators participate in a cooperative game that gives the users a strong assurance that they see all of the validations that the validators to which they are connected know about, and that blocks are not being skipped in an effort to censor transactions. In particular, if the modifications given at the end of the protocol specification are made, we are confident that Casper is a practical economic blockchain-based consensus protocol.

\bibliographystyle{plain}
\bibliography{mybib}

\end{document}
